## 서버 간 통신
### 마이크로서비스 아키텍쳐(MSA: Microservice Architecture)
- 서비스 규모를 작게 나누어 구성한 아키텍쳐
- 나눈 서비스 간 통신하는 경우, 이런 상황에서의 통신을 `서버 간 통신`이라고 함.

### 서버 간 통신이란?
- 한 서버가 다른 서버에 통신을 요청하는 것
- 한 대는 서버, 다른 한 대는 클라이언트가 되는 구조
- 몇 가지 프로토콜에 의해 다양한 통신 방식을 적용할 수 있지만, 가장 많이 사용하는 방식은 HTTP/HTTPS 방식.

## 스프링 부트의 동작 방식
- 스프링 부트에서 `spring-boot-starter-web` 모듈을 사용하면 기본적으로 톰캣을 사용하는 스프링 MVC 구조를 기반으로 동작함.
### 서블릿(Servlet)
- 클라이언트의 요청을 처리하고 결과를 반환하는 자바 웹 프로그래밍 기술
- 서블릿은 서블릿 컨테이너에서 관리함.
    - 서블릿 인스턴스(Servlet Instance)를 생성하고 관리하는 역할을 관리하는 역할 수행
    - 톰캣: WAS의 역할과 서블릿 컨테이너 역할을 수행하는 대표적 컨테이너
    - 서블릿 컨테이너의 특징
        - 서블릿 객체를 생성, 초기화, 호출, 종료하는 생명 주기를 관리
        - 서블릿 객체는 싱글톤 패턴으로 관리됨.
        - 멀티 스레딩을 지원함.
- 스프링에서는 DispatcherServlet이 서블릿 역할을 수행함.
    - DispatcherServlet의 동작 방식<br>
        1. DispatcherServlet으로 요청(HttpServletRequest)이 들어오면 DispatcherServlet이 핸들러 매핑(Handler Mapping)을 통해 요청 URI에 매핑된 핸들러(컨트롤러)를 탐색함.
        2. 핸들러 어댑터(HandlerAdapter)로 컨트롤러를 호출함.
        3. 핸들러 어댑터에 컨트롤러의 응답이 돌아오면 ModelAndView로 응답을 가공해 반환함.
        4. 뷰 형식으로 리턴하는 컨트롤러를 사용할 때에는 뷰 리졸버(View Resolver)를 통해 뷰(View)를 받아 리턴함.
- 핸들러 매핑이란?
    - 요청 정보를 기준으로 어떤 컨트롤러를 사용할지 선정하는 인터페이스
    - 대표적인 구현체 클래스
        - `BeanNameUrlHandlerMapping`
            - 빈 이름을 URL로 사용하는 매핑 전략
            - 빈을 정의할 때 슬래시("/")가 들어가면 매핑 대상이 됨.
            - EX) @Bean("/Hello")
        - `ControllerClassNameHandlerMapping`
            - URL과 일치하는 클래스 이름을 갖는 빈을 컨트롤러로 사용하는 전략.
            - 이름 중 Controller를 제외하고 앞부분에 작성된 suffix를 소문자로 매핑함.
        - `SimplUrlHandlerMapping`
            - URL 패턴에 매핑된 컨트롤러를 사용하는 전략
        - `DefaultAnnotationHandlerMapping`
            - 어노테이션으로 URL과 컨트롤러를 매핑하는 방법

- 뷰 리졸버란?
    - 뷰의 렌더링 역할을 담당하는 뷰 객체를 반환함.

## 레이어드 아키텍쳐
- 애플리케이션의 컴포넌트를 유사 관심사를 기준으로 레이어로 묶어 수평적으로 구성한 구조
- 여러 방면에서 쓰이는 개념으로, 어떻게 설계하느냐에 따라 용어와 계층의 수가 달라짐.
- 일반적인 레이어드 아키텍쳐
    - `프레젠테이션 계층`
        - 애플리케이션의 최상단 계층, 클라이언트의 요청을 해석하고 응답하는 역할
        - UI나 API를 제공함.
        - 프레젠테이션 계층은 별도의 비즈니스 로직을 포함하고 있지 않기 때문에 비즈니스 계층으로 요청을 위임하고 받은 결과를 응답하는 역할만 수행됨.
    - `비즈니스 계층`
        - 상황에 따라 서비스(Service) 계층이라고도 함.
        - 핵심 비즈니스 로직을 구현하는 영역
        - 트랜잭션 처리나 유효성 검사 등의 작업도 수행함.
    - `데이터 접근 계층`
        - 상황에 따라 영속(Persistence) 계층이라고도 함.
        - 데이터베이스에 접근해야 하는 작업을 수행함.

## 디자인 패턴
### GoF: Gang of Four
- 디자인 패턴을 구체화하고 체계화하여 분류한 4인의 인물


### 생성 패턴
    - 객체 생성에 사용되는 패턴
    - 객체를 수정해도 호출부가 영향을 받지 않게 됨.
### 구조 패턴
    - 객체를 조합해서 더 큰 구조를 만드는 패턴
### 행위 패턴
    - 객체 간의 알고리즘이나 책임 분배에 관한 패턴
    - 객체 하나로는 수행할 수 없는 작업을 여러 객체를 이용해 작업을 분해
    - 결합도 최소화를 고려할 필요가 있음.


|생성(Creational) 패턴|구조(Structual) 패턴|행위(Behavioral) 패턴|
|--|--|--|
|추상 팩토리(Abstract Factory)|어댑터(Adapter)|책임 연쇄(Chain of Responsibility)|
|빌더(Builder)|브리지(Bridge)|커맨드(Command)|
|팩토리 메서드(Factory Method)|컴포지트(Composite)|인터프리터(Interpreter)|
|프로토타입(Prototype)|데코레이터(Decorator)|이터레이터(Iterator)|
|싱글톤(Singleton)|퍼사드(Facade)|미디에이터(Mediater)|
||플라이웨이트(Flyweight)|메멘토(Memento)|
||프락시(Proxy)|옵저버(Observer)|
|||스테이트(State)|
|||스트레티지(Strategy)|
|||템플릿 메서드(Template Method)|
|||비지터(Visitor)|

## 생성 패턴
- 추상 팩토리: 구체적인 클래스를 지정하지 않고 상황에 맞는 객체를 생성하기 위한 인터페이스를 제공하는 패턴
- 빌더: 객체의 생성과 표현을 분리해 객체를 생성하는 패턴
- 팩토리 메서드: 객체 생성을 서브 클래스로 분리해서 위임하는 패턴
- 프로토타입: 원본 객체를 복사해 객체를 생성하는 패턴
- 싱글톤: 한 클래스마다 인스턴스를 하나만 생성해서 인스턴스가 하나임을 보장하고 어느 곳에서 접근할 수 있게 제공하는 패턴

## 구조 패턴
- 어댑터: 클래스의 인터페이스를 의도하는 인터페이스로 변환하는 패턴
- 브리지: 추상화와 구현을 분리해서 각각 독립적으로 변형케 하는 패턴
- 컴포지트: 여러 객체로 구성된 복합 객체와 단일 객체를 클라이언트에서 구별 없이 다루는 패턴
- 데코레이터: 객체의 결합을 동적으로 유연하게 확장할 수 있게 하는 패턴
- 퍼사드: 서브 시스템의 인터페이스 집합들에 하나의 통일된 인터페이스를 제공하는 패턴
- 플라이웨이트: 특정 클래스의 인스턴스 한 개를 가지고 여러 개의 `가상 인스턴스`를 제공할 때 사용하는 패턴
- 프락시: 특정 객체를 직접 참조하지 않고 해당 객체를 대행(프락시)하는 객체를 통해 접근하는 패턴

## 행위 패턴
- 책임 연쇄: 요청 처리 객체를 집합으로 만들어 결합을 느슨하게 만드는 패턴
- 커맨드: 실행될 기능을 캡슐화해서 주어진 여러 기능을 실행하도록 클래스를 설계하는 패턴
- 인터프리터: 주어진 언어의 문법을 위한 표현 수단을 정의하고 해당 언어로 구성된 문장을 해석하는 패턴
- 이터레이터: 내부 구조를 노출하지 않으면서 해당 객체의 집합 원소에 순차적으로 접근하는 방법을 제공하는 패턴
- 미디에이터: 한 집합에 속한 객체들의 상호작용을 캡슐화하는 객체를 정의한 패턴
- 메멘토: 객체의 상태 정보를 저장하고 필요에 따라 상태를 복원하는 패턴
- 옵저버: 객체의 상태 변화를 관찰하는 관찰자들, 즉 옵저버 목록을 객체에 등록해 상태가 변할 때마다 메서드 등을 통해 객체가 직접 옵저버에게 통지하게 하는 디자인 패턴

## REST API
- 대중적으로 가장 많이 사용되는 애플리케이션 인터페이스
- REST API를 통해 클라이언트는 서버에 접근하고 자원을 조작할 수 있음.

### REST란?
- `Representational State Transfer`의 약자
- 월드 와이드 웹(WWW)과 같은 분산 하이퍼미디어 시스템 아키텍쳐의 한 형식
- 주고받는 자원에 이름을 규정하고 URI에 명시해 HTTP 메서드(GET, POST, PUT, DELETE)를 통해 해당 자원의 상태를 주고받는 것

### REST API란?
- Application Programming Interface의 약자
- 애플리케이션에서 제공하는 인터페이스
- API를 통해 서버 또는 프로그램 사이를 연결할 수 있음.
- REST 아키텍쳐를 따르는 시스템/애플리케이션 인터페이스
- REST 아키텍쳐를 구현하는 웹 서비스를 `RESTful하다`라고 표현.

### REST의 특징
- 유니폼 인터페이스
    - `일괄된 인터페이스`
    - REST 서버는 HTTP 표준 전송 규약을 따르기 때문에 프로그램 언어에 상관 없이 풀랫폼 및 기술에 종속되지 않고 타 언어, 플랫폼, 기술 등과 호환해 사용할 수 있음.
- 무상태성
    - 서버에 상태 정보를 따로 보관하거나 관리하지 않는다는 의미
    - 서버는 클라이언트가 보낸 요청에 대해 세션이나 쿠키 정보를 별도로 보관하지 않움
         - 그렇기 때문에 한 클라이언트가 여러 요청을 보내든 여러 클라이언트가 각각 하나의 요청을 보내든 개별적으로 처리함.
    - 서버가 불필요한 정보를 관리하지 않기 때문에 비즈니스 로직의 자유도가 높고 설계가 단순함.
- 캐시 가능성
    - REST는 HTTP 표준을 그대로 사용하기 때문에 HTTP의 캐싱 기능을 적용할 수 있음.
        - 응답과 요청이 모든 캐싱 가능한지 명시가 필요
        - 캐싱이 가능한 경우 클라이언트에서 캐시에 저장해두고 같은 요청에 대해 해당 데이터를 가져다 사용
    - 서버의 트랜잭션 부하가 줄어 효율적이며 사용자 입장에서 성능이 개선됨.
- 레이어 시스템
    - REST 서버는 네트워크 상의 여러 계층으로 구성됨.
    - 서버의 복잡도와 관계없이 클라이언트는 서버와 연결되는 포인트만 알면 됨.
- 클라이언트-서버 아키텍쳐
    - REST 서버는 API를 제공하고 클라이언트는 사용자 정보를 관리하는 구조로 분리해 설계함.

### REST의 URI 설계 규칙
- URI의 마지막에는 `/`를 포함하지 않음.
    - O) `http://localhost.com/product`
    - X) `http://localhost.com/product/`
- 언더바(_)는 사용하지 않음. 대신 하이픈(-)을 사용함
    - O) `http://localhost.com/provider-company-name`
    - X) `http://localhost.com/provider_company_name`
- 행위(동사)가 아닌 결과(명사)를 포함함.
    - O) `http://localhost.com/product/123`
    - X) `http://localhost.com/delete-product/123`
- 소문자로 작성해야 함.
    - URI 리소스 경로에는 대문자 사용을 피하는 것이 좋음.
    - 일부 웹 서버의 운영체제는 리소스 경로 부분의 대소문자를 다른 문자로 인식함.
        - RFC 3986은 URI 문법 형식을 정의하고 있음.
        - 호스트의 구성요소를 제외하고 URI의 대소문자를 구분해서 정의하고 있음.
- 파일 확장자는 URI에 포함하지 않음.
    - HTTP에서 제공하는 Accept 헤더를 사용하는 것이 좋음.